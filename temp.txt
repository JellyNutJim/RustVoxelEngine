use winit::{ 
    application::ApplicationHandler,
    event::WindowEvent,
    event_loop::{ActiveEventLoop, ControlFlow, EventLoop},
    window::{Window, WindowId}};

use std::time::Instant;

#[derive(Default)]
struct App {
   window: Option<Window>,
   resize_timer: Option<Instant>,
}

impl ApplicationHandler for App {
   fn resumed(&mut self, event_loop: &ActiveEventLoop) {
       let window_attributes = Window::default_attributes()
           .with_title("RustVoxelEngine");
       self.window = Some(event_loop.create_window(window_attributes).unwrap());
   }

   fn window_event(&mut self, event_loop: &ActiveEventLoop, id: WindowId, event: WindowEvent) {
       match event {
           WindowEvent::CloseRequested => {
               println!("The close button was pressed; stopping");
               event_loop.exit();
           },
           WindowEvent::RedrawRequested => {
               self.window.as_ref().unwrap().request_redraw();
           },
           WindowEvent::Resized(size) => {
               // Only trigger if 100ms have passed since last resize
               if self.resize_timer.is_none() || self.resize_timer.unwrap().elapsed().as_millis() >= 100 {
                   println!("New resolution: {}x{}", size.width, size.height);
                   self.resize_timer = Some(Instant::now());
               }
           },
           _ => (),
       }
   }
}

fn main() {
    let event_loop = EventLoop::new().unwrap();

    // ControlFlow::Poll continuously runs the event loop, even if the OS hasn't
    // dispatched any events. This is ideal for games and similar applications.
    event_loop.set_control_flow(ControlFlow::Poll);

    // ControlFlow::Wait pauses the event loop if no events are available to process.
    // This is ideal for non-game applications that only update in response to user
    // input, and uses significantly less power/CPU time than ControlFlow::Poll.
    event_loop.set_control_flow(ControlFlow::Wait);

    let mut app = App::default();
    event_loop.run_app(&mut app).expect("msg");
}